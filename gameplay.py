# -------------------------------------------------------------------------------------------------------------------- #
# gameplay.py: περιέχει την κλάση Gameplay                                                                             #
# -------------------------------------------------------------------------------------------------------------------- #
from pgn import FilePGN
from board import Board


class Gameplay:
    """
    Συνδυάζει τις πληροφορίες που έχει αποσπάσει το FilePGN και τα στοιχεία του Board, διαχειρίζεται τα Piece (κομμάτια)
    του πίνακα ελέγχοντας ποιο κομμάτι πρέπει να κινηθεί και σε ποια θέση
    Χρησιμοποιεί τη λίστα με τις κινήσεις από το αρχείο pgn, έπειτα πραγματοποιώντας τους κατάλληλους ελέγχους μεταβάλει
    τη "σκακιέρα"
    Επειδή δεν υπάρχει η δυνατότητα να κινηθούμε "προς τα πίσω", στους προηγούμενους γύρους δηλαδή, η κλάση αυτή
    χρησιμοποιείται από την κλάση game_loader.GameLoader, η οποία αποθηκεύει στιγμιότυπα του κάθε γύρου

    Ορίσματα:
    ---------
        file_path (str):
            διεύθυνση αρχείου pgn

        no_of_game (int):
            αριθμός παιχνιδιού (σε περίπτωση που το αρχείο περιέχει περισσότερα από ένα παιχνίδια)

    Μέθοδοι:
    --------
        next_move(self) -> str | None:
            εκτέλεση επόμενης κίνησης, επιστρέφει το όνομα του κομματιού που αιχμαλωτίστηκε
    """
    def __init__(self, file_path: str, no_of_game: int):
        # αρχικοποίηση κλάσεων FilePGN και Board -----------------------------------------------------------------------
        file = FilePGN(file_path)
        self.brd = Board()

        # αποθήκευση λεξικού με τις επεξεργασμένες πληροφορίες του παιχνιδιού που επιλέχτηκε ---------------------------
        self.game_dict = file.get_info(no_of_game)

        # key-word "moves": επιστρέφει λίστα με τις κινήσεις του συγκεκριμένου παιχνιδιού
        self.moves = self.game_dict["moves"]

        # αποθήκευση μήκους λίστας κινήσεων
        self.moves_length = len(self.moves)

        # αρχικοποίηση λιστών με πληροφορίες για τον έλεγχο των κινήσεων -----------------------------------------------
        # λίστα με τις στήλες της σκακιέρας
        self.letters = ["a", "b", "c", "d", "e", "f", "g", "h"]
        # λίστα με τις σειρές της σκακιέρας
        self.numbers = ["1", "2", "3", "4", "5", "6", "7", "8"]
        # λίστα με τις διαγωνίους της σκακιέρας
        self.diags = [["a1", "b2", "c3", "d4", "e5", "f6", "g7", "h8"],
                      ["a2", "b3", "c4", "d5", "e6", "f7", "g8"],
                      ["a3", "b4", "c5", "d6", "e7", "f8"],
                      ["a4", "b5", "c6", "d7", "e8"],
                      ["a5", "b6", "c7", "d8"],
                      ["a6", "b7", "c8"],
                      ["a7", "b8"],
                      ["a8", "b7", "c6", "d5", "e4", "f3", "g2", "h1"],
                      ["a7", "b6", "c5", "d4", "e3", "f2", "g1"],
                      ["a6", "b5", "c4", "d3", "e2", "f1", ],
                      ["a5", "b4", "c3", "d2", "e1"],
                      ["a4", "b3", "c2", "d1"],
                      ["a3", "b2", "c1"],
                      ["a2", "b1"],
                      ["h2", "g3", "f4", "e5", "d6", "c7", "b8"],
                      ["h3", "g4", "f5", "e6", "d7", "c8"],
                      ["h4", "g5", "f6", "e7", "d8"],
                      ["h5", "g6", "f7", "e8"],
                      ["h6", "g7", "f8"],
                      ["h7", "g8"],
                      ["h7", "g6", "f5", "e4", "d3", "c2", "b1"],
                      ["h6", "g5", "f4", "e3", "d2", "c1"],
                      ["h5", "g4", "f3", "e2", "d1"],
                      ["h4", "g3", "f2", "e1"],
                      ["h3", "g2", "f1"],
                      ["h2", "g1"]
                      ]
        # η λίστα knight_moves περιέχει όλες τις πιθανές κινήσεις (σημεία) για τον ίππο,
        # θεωρώντας ότι ο ίππος βρίσκεται στη θέση (0, 0)
        self.knight_moves = [(-2, -1), (-2, 1), (2, -1), (2, 1),
                             (-1, -2), (-1, 2), (1, -2), (1, 2)]


        # αρχικοποίηση μεταβλητής που μετράει τους γύρους
        self.round = -1

        # αρχικοποίηση βοηθητικών μεταβλητών (για τη γραφική αναπαράσταση) ---------------------------------------------
        # δήλωση ότι ο βασιλιάς έχει ματ
        self.check = None
        # δήλωση ότι έχει γίνει κατάληψη κομματιού
        self.capture = False

    def next_move(self) -> str | None:
        """
        Εκτέλεση επόμενης κίνησης
        Ανάλογα την εκάστοτε κίνηση, γίνεται έλεγχος των κομματιών και μετακίνηση του κατάλληλου

        Επιστρεφόμενο αντικείμενο:
        --------------------------
            (str | None):
                (str) το όνομα (piece.name) του κομματιού που αιχμαλωτίστηκε
                (None) δεν πραγματοποιήθηκε κάποια κίνηση (πιθανό εσφαλμένο αρχείο)
        """
        # επαναφορά των βοηθητικών μεταβλητών στην προκαθορισμένη τιμή
        self.check = None
        self.capture = False

        # επαύξηση γύρου
        self.round += 1
        # στήσιμο των κομματιών
        self.brd.set_pieces()
        self.brd.update_squares()
        # εναλλαγή δείκτη παίκτη που πρόκειται να παίξει (λευκός - μαύρος)
        if self.round % 2 == 0:
            tag = "w"
        else:  # self.round % 2 == 1
            tag = "b"

        # αποθήκευση τρέχουσας κίνησης
        move = self.moves[self.round]

        if "x" in move:
            # κάποιο κομμάτι αιχμαλωτίστηκε, οπότε η self.capture για αυτόν τον γύρο γίνεται True
            # θα χρησιμοποιηθεί από την gui.GUI για την αναπαραγωγή των ήχων
            self.capture = True

        # ειδικές κινήσεις / σημάνσεις κινήσεων ------------------------------------------------------------------------
        # >> εξαιρετική κίνηση / λανθάνουσα κίνηση <<
        if "!" in move or "?" in move:
            move = move[:len(move) - 1]
            if "!" in move or "?" in move:
                move = move[:len(move) - 1]

        # >> check / checkmate <<
        if "+" in move or "#" in move:
            # με αυτήν τη βοηθητική μεταβλητή δηλώνεται ότι σε αυτόν τον γύρο έχει ματ ο βασιλιάς
            self.check = "b" if tag == "w" else "w"
            move = move[:len(move) - 1]

        # >> ροκέ <<
        if move == "O-O" or move == "O-O-O":
            # η κινήσεις O-O και 0-0-0 ονομάζονται μικρό και μεγάλο ροκέ αντίστοιχα
            for piece in self.brd.pieces:
                if piece.name[0] == "k" and piece.name[1] == tag:
                    if tag == "w":
                        if move == "O-O":
                            # o βασιλιάς κάνει μικρό ροκέ με τον δεξί πύργο
                            self.brd.move_piece(piece.pos, "g1")
                            self.brd.move_piece("h1", "f1")
                            return "   "
                        if move == "O-O-O":
                            # o βασιλιάς κάνει μεγάλο ροκέ με τον αριστερό πύργο
                            self.brd.move_piece(piece.pos, "c1")
                            self.brd.move_piece("a1", "d1")
                            return "   "

                    elif tag == "b":
                        if move == "O-O":
                            # o βασιλιάς κάνει μικρό ροκέ με τον δεξί πύργο
                            self.brd.move_piece(piece.pos, "g8")
                            self.brd.move_piece("h8", "f8")
                            return "   "
                        if move == "O-O-O":
                            # o βασιλιάς κάνει μεγάλο ροκέ με τον αριστερό πύργο
                            self.brd.move_piece(piece.pos, "c8")
                            self.brd.move_piece("a8", "d8")
                            return "   "

        # >> εξέλιξη πιονιού <<
        pawn_promotion = False
        # μεταβλητή για αποθήκευση χαρακτηρισμού προαγωγής πιονιού
        # ("q"=προαγωγή σε βασίλισσα, "r"=προαγωγή σε πύργο κ.ο.κ.)
        promotion = ""
        # μεταβλητή για αποθήκευση ονόματος αιχμαλωτισμένου πιονιού εάν έχουμε en-passant (εν-διελεύσει)
        # στη συγκεκριμένη περίπτωση το πιόνι εκτελεί "κρυφά" δύο κινήσεις όπως θα φανεί παρακάτω
        en_passant = ""

        if "=" in move:
            # έχουμε εξέλιξη πιονιού σε αυτόν τον γύρο (πχ e8=Q ή fxe8=R κλπ)
            pawn_promotion = True
            # κρατάω την πληροφορία που με ενδιαφέρει (σε τι προήχθη το πιόνι) και κρατάω την υπόλοιπη κίνηση σαν μία
            # απλή κίνηση (πχ e8=Q -> promotion == q και move == e8)
            promotion = move[-1].lower()
            move = move[:len(move) - 2]

        # κίνηση πιονιού -----------------------------------------------------------------------------------------------
        if len(move) == 2 or (len(move) == 4 and move[0].islower() and move[1] == "x"):
            # απλή κίνηση μπροστά (πχ e4)
            if len(move) == 2:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω το πιόνι που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # ελέγχω εάν είναι πιόνι κατάλληλου αρώματος και κατάλληλης στήλης (file)
                    if piece.name[0] == "p" and piece.name[1] == tag and piece.pos[0] == move[0]:
                        # τα λευκά πιόνια αυξάνουν το rank της θέσης τους όταν μετακινούνται, επομένως η διαφορά στο
                        # της τρέχουσας θέσης με τη μελοντική είναι αρνητική
                        # για τα μαύρα πιόνια ισχύει το αντίθετο
                        difference_in_rank = int(piece.pos[1]) - int(move[1])
                        if difference_in_rank < -2 or difference_in_rank > 2:
                            # ένα πιόνι δεν μπορεί να μετακινηθεί πάνω από δύο θέσεις
                            continue

                        # στην περίπτωση που το πιόνι κινηθεί δύο κελιά εμπρός, πρέπει να γίνει έλεγχος ότι δεν
                        # υπάρχει κάποιο άλλο πιόνι μπροστά του
                        # (το άλλο πιόνι πρέπει να εκτελέσει την κίνηση ένα κελί μπροστά)
                        if difference_in_rank == -2:
                            # ένα λευκό πιόνι εκτέλεσε κίνηση 2 κελιά μπροστά
                            if self.brd.squares[piece.pos[0] + str(int(piece.pos[1]) + 1)]:
                                # εάν η παραπάνω συνθήκη είναι αληθής, το κελί μπροστά στο πιόνι είναι κατειλημμένο
                                # οπότε συνεχίζουμε την αναζήτηση του πιονιού
                                continue

                        if difference_in_rank == 2:
                            # ένα μαύρο πιόνι εκτέλεσε κίνηση 2 κελιά μπροστά
                            if self.brd.squares[piece.pos[0] + str(int(piece.pos[1]) - 1)]:
                                # εάν η παραπάνω συνθήκη είναι αληθής, το κελί μπροστά στο πιόνι είναι κατειλημμένο
                                # οπότε συνεχίζουμε την αναζήτηση του πιονιού
                                continue
                        # εάν δεν ισχύει καμία από τις παραπάνω συνθήκες, το πιόνι μπορεί να προχωρήσει μπροστά

                        # έλεγχος προαγωγής
                        if pawn_promotion:
                            # το πιόνι έφτασε στην απέναντι μεριά της σκακιέρας, οπότε και προάγεται
                            # (αλλάζει το όνομά του)
                            piece.name = promotion + tag + "+"
                        return self.brd.move_piece(piece.pos, move)

            # το πιόνι αιχμαλωτίζει (πχ dxe4)
            elif len(move) == 4 and move[0].islower() and move[1] == "x":
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω το πιόνι που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # ελέγχω εάν είναι πιόνι κατάλληλου χρώματος
                    if piece.name[0] == "p" and piece.name[1] == tag and piece.pos[0] == move[0]:
                        if not self.brd.squares[move[2:]]:
                            # ένα πιόνι αιχμαλώτισε κενό κελί, σημαίνει ότι έχουμε "en passant" (εν διελεύσει)
                            # το πιόνι θα κινηθεί "κρυφά" αιχμαλωτίζοντας το κομμάτι
                            # και μετά θα κινηθεί στην πραγματική του θέση
                            if tag == "w":
                                # κάποιο λευκό πιόνι εκτέλεσε "en passant"
                                temp_move_number = move[3]
                                temp_move_number = int(temp_move_number) - 1
                                temp_move = move[2] + str(temp_move_number)
                                if pawn_promotion:
                                    piece.name = promotion + tag + "+"
                                # προσωρινή κίνηση (δεξιά ή αριστερά) για κατάληψη του αντίπαλου πιονιού
                                en_passant = self.brd.move_piece(piece.pos, temp_move)

                            elif tag == "b":
                                # κάποιο μαύρο πιόνι εκτέλεσε "en passant"
                                temp_move_number = move[3]
                                temp_move_number = int(temp_move_number) + 1
                                temp_move = move[2] + str(temp_move_number)
                                if pawn_promotion:
                                    piece.name = promotion + tag + "+"
                                # προσωρινή κίνηση (δεξιά ή αριστερά) για κατάληψη του αντίπαλου πιονιού
                                en_passant = self.brd.move_piece(piece.pos, temp_move)

                        piece_rank = int(piece.pos[1])
                        if piece_rank - 1 != int(move[3]) and piece_rank + 1 != int(move[3]):
                            # εδώ γίνεται έλεγχος αν το πιόνι που βρέθηκε μπορεί να αιχμαλωτίσει
                            # πρέπει το rank να είναι κατά μία μονάδα μικρότερο ή μεγαλύτερο
                            continue
                        if pawn_promotion:
                            piece.name = promotion + tag + "+"
                        # εδώ πραγματοποιείται η τελική (πραγματική) κίνηση του πιονιού
                        # (εάν είχε εκτελέσει και en-passant)
                        # αποθηκεύεται το όνομα του αιχμαλωτισμένου κομματιού
                        captured_piece_name = self.brd.move_piece(piece.pos, move[2:])
                        # επειδή η κίνηση περιελάμβανε τον χαρακτήρα "x", πρέπει να επιστραφεί ένα όνομα αιχμαλωτισμένου
                        # κομματιού διαφορετικό της "   ", που σημαίνει ότι το πιόνι απλώς μετακινήθηκε
                        # εάν είναι "   ", επιστρέφεται το όνομα από το αιχμαλωτισμένο κομμάτι από en-passant
                        if captured_piece_name != "   ":
                            return captured_piece_name
                        else:
                            if en_passant:
                                # εάν το en_passant έχει λάβει τιμή διαφορετική του "", αλλιώς έχουμε πιθανό σφάλμα στο
                                # αρχείο, δε θα μετακινηθεί κάποιο κομμάτι και η μέθοδος θα επιστρέψει None (στο τέλος)
                                return en_passant

        # κίνηση βασιλιά (king K) --------------------------------------------------------------------------------------
        elif move[0] == "K":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            for piece in self.brd.pieces:
                # εύρεση βασιλιά (μοναδικό κομμάτι) και μετακίνηση
                if piece.name[0] == "k" and piece.name[1] == tag:
                    return self.brd.move_piece(piece.pos, move[1:])

        # κίνηση βασίλισσας (Queen Q) ----------------------------------------------------------------------------------
        elif move[0] == "Q":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση Q__: βασίλισσα μετακινείται (πχ Qf3)
            if len(move) == 3:
                # διαγώνιες κινήσεις Q__ ------------------------------------------
                for piece in self.brd.pieces:
                    flag = False
                    # εύρεση κομματιού
                    if piece.name[0] == "q" and piece.name[1] == tag:
                        # υπάρχει η πιθανότητα, εάν έχουμε δύο βασίλισσες, να βρίσκονται στην ίδια διαγώνιο,
                        # η μία όμως να εμποδίζεται να κινηθεί από κάποιο άλλο κομμάτι
                        # σε αυτήν την περίπτωση πρέπει  να ελεγχθεί έαν η διαδρομή της από το σημείο εκκίνησης
                        # εώς το σημείο προορισμού είναι ελεύθερη
                        # διαφορετικά θα μετακινηθεί η πρώτη που θα βρεθεί στη διαπέραση των κομματιών, και ίσως
                        # εκτελέσει μη νόμιμη κίνηση

                        # έλεγχος αν κομμάτι και θέση επίθεσης είναι στην ίδια διαγώνιο
                        for diag in self.diags:
                            # ο έλεγχος θα επιτύχει εάν και τα δύο βρίσκονται στην ίδια διαγώνιο
                            if piece.pos in diag and move[1:] in diag:
                                # κομμάτι και θέση επίθεσης βρίσκονται στην ίδια διαγώνιο
                                # έλεγχος εάν η κίνηση μπορεί να εκτελεστεί από αυτό το κομμάτι
                                for square in diag:
                                    # διατρέχουμε τα κελιά μέχρι να βρούμε το ένα απο τα δύο (κομμάτι ή θέση επίθεσης)
                                    if square != piece.pos and square != move[1:] and flag is False:
                                        continue
                                    # όταν βρεθεί το ένα, ενεργοποιείται το flag, ώστε να ξεκινήσει ο έλεγχος
                                    # το flag απενεργοποιείται μόλις βρεθεί και το δεύτερο
                                    if square == piece.pos or square == move[1:]:
                                        # την πρώτη φορά που θα ισχύσει η συνθήκη, σημαίνει ότι είμαστε εντός εύρους
                                        # κίνησης και ενεργοποιείται το flag (χρησιμοποιείται στον έλεγχο παρακάτω)
                                        # τη δεύτερη φορά σημαίνει ότι βγαίνουμε από το εύρος και απενεργοποιείται
                                        flag = not flag
                                        continue
                                    # όσο το flag είναι ενεργό, πραγματοποιείται έλεγχος των κελιών
                                    if flag:
                                        # έλεγχος αν είναι το επόμενο κελί
                                        if square == move[1:] or square == move[1:]:
                                            return self.brd.move_piece(piece.pos, move[1:])

                                        # εάν κάποιο από τα κελιά είναι ενεργό, διακόπτεται η αναζήτηση
                                        if self.brd.squares[square]:
                                            break
                                # εάν το for τελειώσει ομαλά, η διαδρομή του κομματιού είναι ελεύθερη
                                # και μπορεί να μετακινηθεί
                                else:
                                    return self.brd.move_piece(piece.pos, move[1:])

                # κάθετες/οριζόντιες κινήσεις Q__ ---------------------------------
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τη βασίλισσα που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # ελέγχω εάν είναι πύργος κατάλληλου χρώματος
                    if piece.name[0] == "q" and piece.name[1] == tag:
                        # υπάρχει η πιθανότητα, εάν έχουμε δύο βασίλισσες, να βρίσκονται στην ίδια στήλη ή στην ίδια
                        # γραμμή, η μία όμως να εμποδίζεται να κινηθεί από κάποιο άλλο κομμάτι
                        # σε αυτήν την περίπτωση πρέπει  να ελεγχθεί έαν η διαδρομή της από το σημείο εκκίνησης
                        # εώς το σημείο προορισμού είναι ελεύθερη
                        # διαφορετικά θα μετακινηθεί η πρώτη που θα βρεθεί στη διαπέραση των κομματιών, και ίσως
                        # εκτελέσει μη νόμιμη κίνηση

                        # βασίλισσες στην ίδια στήλη (ίδιο letter)
                        if piece.pos[0] == move[1]:

                            # 1. queen rank < move
                            if piece.pos[1] < move[2]:
                                for num in self.numbers:
                                    # εδώ γίνεται έλεγχος αν υπάρχει κάποιο κομμάτι που εμποδίζει την κίνηση
                                    if num <= piece.pos[1] or num >= move[2]:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    if self.brd.squares[piece.pos[0] + num]:
                                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                        # αναζήτηση των κομματιών
                                        break
                                else:
                                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                                    return self.brd.move_piece(piece.pos, move[1:])

                            # 2. queen rank > move
                            if piece.pos[1] > move[2]:
                                for num in self.numbers:
                                    # εδώ γίνεται έλεγχος αν υπάρχει κάποιο κομμάτι που εμποδίζει την κίνηση
                                    if num <= move[2] or num >= piece.pos[1]:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    if self.brd.squares[piece.pos[0] + num]:
                                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                        # αναζήτηση των κομματιών
                                        break
                                else:
                                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                                    return self.brd.move_piece(piece.pos, move[1:])

                        # βασίλισσες στην ίδια γραμμή (ίδιο number)
                        elif piece.pos[1] == move[2]:
                            # 1. queen letter > move
                            if piece.pos[0] > move[1]:
                                for letter in self.letters:
                                    if letter <= move[1] or letter >= piece.pos[0]:
                                        continue
                                    if self.brd.squares[letter + piece.pos[1]]:
                                        break
                                else:
                                    return self.brd.move_piece(piece.pos, move[1:])

                            # 2. queen letter < move
                            if piece.pos[0] < move[1]:
                                for letter in self.letters:
                                    if letter >= move[1] or letter <= piece.pos[0]:
                                        continue
                                    if self.brd.squares[letter + str(piece.pos[1])]:
                                        break
                                else:
                                    return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις Q___: συγκεκριμένη βασίλισσα μετακινείται (πχ Qcb4 ή Q3b4)
            if len(move) == 4:
                for piece in self.brd.pieces:
                    if piece.name[0] == "q" and piece.name[1] == tag:
                        if piece.pos[0] == move[1]:
                            # περίπτωση Qcb4
                            return self.brd.move_piece(piece.pos, move[2:])

                        if piece.pos[1] == move[1]:
                            # περίπτωση Q3b4
                            return self.brd.move_piece(piece.pos, move[2:])

            # περιπτώσεις Q____: συγκεκριμένη βασίλισσα μετακινείται (πχ Qb1b4 ή Qa4b4)
            elif len(move) == 5:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τη βασίλισσα που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # ελέγχω εάν είναι πύργος κατάλληλου χρώματος
                    if piece.name[0] == "q" and piece.name[1] == tag and piece.pos == move[1:3]:
                        return self.brd.move_piece(piece.pos, move[3:])

        # κίνηση ίππου (knight N) --------------------------------------------------------------------------------------
        elif move[0] == "N":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση N__: ίππος μετακινείται (πχ Nf3)
            if len(move) == 3:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τον ίππο που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    if piece.name[0] == "n" and piece.name[1] == tag:
                        # βρέθηκε ο ένας από τους δύο ίππους, πρέπει να γίνει έλεγχος ποιος από τους δύο
                        # μπορεί να εκτελέσει την κίνηση, μιας και ο ίππος κινείται σε L
                        distance_by_letter = self.letters.index(piece.pos[0]) - self.letters.index(move[1])
                        distance_by_rank = self.numbers.index(str(piece.pos[1])) - self.numbers.index(str(move[2]))
                        if (distance_by_letter, distance_by_rank) in self.knight_moves:
                            return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις N___: συγκεκριμένος ίππος μετακινείται (πχ Nfb4 ή N1b4)
            elif len(move) == 4:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τον ίππο που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    if piece.name[0] == "n" and piece.name[1] == tag:
                        if piece.pos[0] == move[1]:
                            # περίπτωση Nfb4
                            return self.brd.move_piece(piece.pos, move[2:])

                        if piece.pos[1] == move[1]:
                            # περίπτωση N1b4
                            return self.brd.move_piece(piece.pos, move[2:])

            # περιπτώσεις N____: συγκεκριμένος ίππος μετακινείται (πχ Nd3b5)
            elif len(move) == 5:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τον ίππο που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    if piece.name[0] == "n" and piece.name[1] == tag:
                        if piece.pos[0] == move[1] and piece.pos[1] == move[2]:
                            # περίπτωση Nfb4
                            return self.brd.move_piece(piece.pos, move[3:])

            # περιπτώσεις N___: συγκεκριμένος ίππος μετακινείται (πχ Nc5e4)
            elif len(move) == 5:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τον ίππο που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    if piece.name[0] == "n" and piece.name[1] == tag:
                        if piece.pos[0] == move[1] and piece.pos[1] == move[2]:
                            # περίπτωση Nc5e4
                            return self.brd.move_piece(piece.pos, move[3:])

        # κίνηση αξιωματικού (bishop B) --------------------------------------------------------------------------------
        elif move[0] == "B":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση B__: αξ/κος μετακινείται (πχ Bf3)
            if len(move) == 3:
                for piece in self.brd.pieces:
                    flag = False
                    # εύρεση κομματιού
                    if piece.name[0] == "b" and piece.name[1] == tag:
                        # υπάρχει η πιθανότητα οι δύο αξιωματικοί να βρίσκονται στην ίδια διαγώνιο,
                        # ο ένας όμως να εμποδίζεται να κινηθεί από κάποιο άλλο κομμάτι
                        # σε αυτήν την περίπτωση πρέπει να ελεγχθεί έαν η διαδρομή του από το σημείο εκκίνησης
                        # εώς το σημείο προορισμού είναι ελεύθερη
                        # διαφορετικά θα μετακινηθεί ο πρώτος που θα βρεθεί στη διαπέραση των κομματιών, και ίσως
                        # εκτελέσει μη νόμιμη κίνηση
                        # έλεγχος αν κομμάτι και θέση επίθεσης είναι στην ίδια διαγώνιο
                        for diag in self.diags:
                            # ο έλεγχος θα επιτύχει εάν και τα δύο βρίσκονται στην ίδια διαγώνιο
                            if piece.pos in diag and move[1:] in diag:
                                # κομμάτι και θέση επίθεσης βρίσκονται στην ίδια διαγώνιο
                                # έλεγχος εάν η κίνηση μπορεί να εκτελεστεί από αυτό το κομμάτι
                                for square in diag:
                                    # διατρέχουμε τα κελιά μέχρι να βρούμε το ένα απο τα δύο (κομμάτι ή θέση επίθεσης)
                                    if square != piece.pos and square != move[1:] and flag is False:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    # όταν βρεθεί το ένα, ενεργοποιείται το flag, ώστε να ξεκινήσει ο έλεγχος
                                    # το flag απενεργοποιείται μόλις βρεθεί και το δεύτερο
                                    if square == piece.pos or square == move[1:]:
                                        # την πρώτη φορά που θα ισχύσει η συνθήκη, σημαίνει ότι είμαστε εντός εύρους
                                        # κίνησης και ενεργοποιείται το flag (χρησιμοποιείται στον έλεγχο παρακάτω)
                                        # τη δεύτερη φορά σημαίνει ότι βγαίνουμε από το εύρος και απενεργοποιείται
                                        flag = not flag
                                        continue
                                    # όσο το flag είναι ενεργό, πραγματοποιείται έλεγχος των κελιών
                                    if flag:
                                        # έλεγχος εάν είναι το επόμενο κελί
                                        if square == move[1:] or square == move[1:]:
                                            return self.brd.move_piece(piece.pos, move[1:])

                                        # εάν κάποιο από τα κελιά είναι ενεργό, διακόπτεται η αναζήτηση
                                        if self.brd.squares[square]:
                                            break
                                # εάν το for τελειώσει ομαλά, η διαδρομή του αξιωματικού είναι ελεύθερη
                                # και μπορεί να μετακινηθεί
                                else:
                                    return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις B___: συγκεκριμένος αξ/κος μετακινείται (πχ Bcb4 ή B3b4)
            elif len(move) == 4:
                for piece in self.brd.pieces:
                    if piece.name[0] == "b" and piece.name[1] == tag:
                        if piece.pos[0] == move[1]:
                            # περίπτωση Bcb4
                            return self.brd.move_piece(piece.pos, move[2:])

                        if piece.pos[1] == move[1]:
                            # περίπτωση B3b4
                            return self.brd.move_piece(piece.pos, move[2:])

        # κίνηση πύργου (rook R) ---------------------------------------------------------------------------------------
        elif move[0] == "R":
            # περίπτωση που κάποιο κομμάτι αιχμαλωτίζεται
            if "x" in move:
                x = move.find("x")
                move = move[:x] + move[x + 1:]

            # περίπτωση R__: πύργος μετακινείται (πχ Rf3)
            if len(move) == 3:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τον πύργο που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # ελέγχω εάν είναι πύργος κατάλληλου χρώματος
                    if piece.name[0] == "r" and piece.name[1] == tag:
                        # υπάρχει η πιθανότητα οι δύο πύργοι να βρίσκονται στην ίδια στήλη ή στην ίδια γραμμή,
                        # ο ένας όμως να εμποδίζεται να κινηθεί από κάποιο άλλο κομμάτι
                        # σε αυτήν την περίπτωση πρέπει  να ελεγχθεί έαν η διαδρομή του πύργου από το σημείο εκκίνησης
                        # εώς το σημείο προορισμού είναι ελεύθερη
                        # διαφορετικά θα μετακινηθεί ο πρώτος που θα βρεθεί στη διαπέραση των κομματιών, και ίσως
                        # εκτελέσει μη νόμιμη κίνηση
                        if piece.pos[0] == move[1]:
                            # πύργοι στην ίδια στήλη (ίδιο letter)
                            # 1. rook rank < move
                            if piece.pos[1] < move[2]:
                                for num in self.numbers:
                                    # εδώ γίνεται έλεγχος αν υπάρχει κάποιο κομμάτι που εμποδίζει την κίνηση
                                    if num <= piece.pos[1] or num >= move[2]:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    if self.brd.squares[piece.pos[0] + num]:
                                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                        # αναζήτηση
                                        break
                                else:
                                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                                    return self.brd.move_piece(piece.pos, move[1:])

                            # 2. rook rank > move
                            if piece.pos[1] > move[2]:
                                for num in self.numbers:
                                    # εδώ γίνεται έλεγχος αν υπάρχει κάποιο κομμάτι που εμποδίζει την κίνηση
                                    if num <= move[2] or num >= piece.pos[1]:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    if self.brd.squares[piece.pos[0] + num]:
                                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                        # αναζήτηση
                                        break
                                else:
                                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                                    return self.brd.move_piece(piece.pos, move[1:])

                        elif piece.pos[1] == move[2]:
                            # πύργοι στην ίδια γραμμή (ίδιο number)
                            # 1. rook letter > move
                            if piece.pos[0] > move[1]:
                                for letter in self.letters:
                                    if letter <= move[1] or letter >= piece.pos[0]:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    if self.brd.squares[letter + piece.pos[1]]:
                                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                        # αναζήτηση
                                        break
                                else:
                                    # το for τελείωσε ομαλά, άρα η κίνηση είναι έγκυρη
                                    return self.brd.move_piece(piece.pos, move[1:])

                            # 2. rook letter < move
                            if piece.pos[0] < move[1]:
                                for letter in self.letters:
                                    if letter >= move[1] or letter <= piece.pos[0]:
                                        # συνεχίζουμε στην επόμενη επανάληψη όσο είμαστε εκτός εύρους κίνησης
                                        continue
                                    if self.brd.squares[letter + str(piece.pos[1])]:
                                        # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                        # αναζήτηση
                                        break
                                else:
                                    # βρέθηκε κελί με κάποιο κομμάτι που εμποδίζει την κίνηση, άρα συνεχίζουμε την
                                    # αναζήτηση
                                    return self.brd.move_piece(piece.pos, move[1:])

            # περιπτώσεις R___: συγκεκριμένος πύργος μετακινείται (πχ Rbb4 ή R4b4)
            elif len(move) == 4:
                # διατρέχω τον πίνακα με τα κομμάτια μέχρι να βρω τον πύργο που πρέπει να κινηθεί
                for piece in self.brd.pieces:
                    # ελέγχω εάν είναι πύργος κατάλληλου χρώματος
                    if piece.name[0] == "r" and piece.name[1] == tag:
                        if piece.pos[0] == move[1]:
                            # περίπτωση Rbb4
                            return self.brd.move_piece(piece.pos, move[2:])

                        if piece.pos[1] == move[1]:
                            # περίπτωση R4b4
                            return self.brd.move_piece(piece.pos, move[2:])

        # η συνάρτηση επιστρέφει None σε περίπτωση που δεν έχει εκτελεστεί κάποια κίνηση
        # σημαίνει ότι κατά πάσα πιθανότητα το αρχείο δεν είναι σωστό
        return None
